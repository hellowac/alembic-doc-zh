
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The Importance of Naming Constraints &#8212; Alembic 1.7.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature_override.css" />
    <link rel="stylesheet" type="text/css" href="_static/changelog.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx_paramlinks.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Running “Batch” Migrations for SQLite and Other Databases" href="batch.html" />
    <link rel="prev" title="Generating SQL Scripts (a.k.a. “Offline Mode”)" href="offline.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running “Batch” Migrations for SQLite and Other Databases"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="offline.html" title="Generating SQL Scripts (a.k.a. “Offline Mode”)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.7.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Importance of Naming Constraints</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="the-importance-of-naming-constraints">
<span id="tutorial-constraint-names"></span><h1>The Importance of Naming Constraints<a class="headerlink" href="#the-importance-of-naming-constraints" title="Permalink to this headline">¶</a></h1>
<p>An important topic worth mentioning is that of constraint naming conventions.
As we’ve proceeded here, we’ve talked about adding tables and columns, and
we’ve also hinted at lots of other operations listed in <a class="reference internal" href="ops.html#ops"><span class="std std-ref">Operation Reference</span></a> such as those
which support adding or dropping constraints like foreign keys and unique
constraints.   The way these constraints are referred to in migration scripts
is by name, however these names by default are in most cases generated by
the relational database in use, when the constraint is created.  For example,
if you emitted two CREATE TABLE statements like this on Postgresql:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_account</span> <span class="p">(</span><span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">);</span>
<span class="n">CREATE</span> <span class="n">TABLE</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_order</span> <span class="p">(</span>
<span class="n">test</span><span class="p">(</span><span class="o">&gt;</span>   <span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
<span class="n">test</span><span class="p">(</span><span class="o">&gt;</span>   <span class="n">user_account_id</span> <span class="n">INTEGER</span> <span class="n">REFERENCES</span> <span class="n">user_account</span><span class="p">(</span><span class="nb">id</span><span class="p">));</span>
<span class="n">CREATE</span> <span class="n">TABLE</span>
</pre></div>
</div>
<p>Suppose we wanted to DROP the REFERENCES that we just applied to the
<code class="docutils literal notranslate"><span class="pre">user_order.user_account_id</span></code> column, how do we do that?  At the prompt,
we’d use <code class="docutils literal notranslate"><span class="pre">ALTER</span> <span class="pre">TABLE</span> <span class="pre">&lt;tablename&gt;</span> <span class="pre">DROP</span> <span class="pre">CONSTRAINT</span> <span class="pre">&lt;constraint_name&gt;</span></code>, or if
using Alembic we’d be using <a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.drop_constraint()</span></code></a>.  But both
of those functions need a name - what’s the name of this constraint?</p>
<p>It does have a name, which in this case we can figure out by looking at the
Postgresql catalog tables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">SELECT</span> <span class="n">r</span><span class="o">.</span><span class="n">conname</span> <span class="n">FROM</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_class</span> <span class="n">c</span> <span class="n">JOIN</span> <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_namespace</span> <span class="n">n</span> <span class="n">ON</span> <span class="n">n</span><span class="o">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">relnamespace</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">JOIN</span> <span class="n">pg_catalog</span><span class="o">.</span><span class="n">pg_constraint</span> <span class="n">r</span>  <span class="n">ON</span> <span class="n">c</span><span class="o">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">conrelid</span>
<span class="n">test</span><span class="o">-&gt;</span>  <span class="n">WHERE</span> <span class="n">c</span><span class="o">.</span><span class="n">relname</span><span class="o">=</span><span class="s1">&#39;user_order&#39;</span> <span class="n">AND</span> <span class="n">r</span><span class="o">.</span><span class="n">contype</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span>
<span class="n">test</span><span class="o">-&gt;</span> <span class="p">;</span>
             <span class="n">conname</span>
<span class="o">---------------------------------</span>
 <span class="n">user_order_user_account_id_fkey</span>
<span class="p">(</span><span class="mi">1</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>The name above is not something that Alembic or SQLAlchemy created;
<code class="docutils literal notranslate"><span class="pre">user_order_user_account_id_fkey</span></code> is a naming scheme used internally by
Postgresql to name constraints that are otherwise not named.</p>
<p>This scheme doesn’t seem so complicated, and we might want to just use our
knowledge of it so that we know what name to use for our
<a class="reference internal" href="ops.html#alembic.operations.Operations.drop_constraint" title="alembic.operations.Operations.drop_constraint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.drop_constraint()</span></code></a> call.  But is that a good idea?   What
if for example we needed our code to run on Oracle as well.  OK, certainly
Oracle uses this same scheme, right?  Or if not, something similar.  Let’s
check:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Oracle</span> <span class="n">Database</span> <span class="mi">10</span><span class="n">g</span> <span class="n">Express</span> <span class="n">Edition</span> <span class="n">Release</span> <span class="mf">10.2.0.1.0</span> <span class="o">-</span> <span class="n">Production</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_account</span> <span class="p">(</span><span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">);</span>

<span class="n">Table</span> <span class="n">created</span><span class="o">.</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">user_order</span> <span class="p">(</span>
  <span class="mi">2</span>     <span class="nb">id</span> <span class="n">INTEGER</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
  <span class="mi">3</span>     <span class="n">user_account_id</span> <span class="n">INTEGER</span> <span class="n">REFERENCES</span> <span class="n">user_account</span><span class="p">(</span><span class="nb">id</span><span class="p">));</span>

<span class="n">Table</span> <span class="n">created</span><span class="o">.</span>

<span class="n">SQL</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="n">constraint_name</span> <span class="n">FROM</span> <span class="n">all_constraints</span> <span class="n">WHERE</span>
  <span class="mi">2</span>     <span class="n">table_name</span><span class="o">=</span><span class="s1">&#39;USER_ORDER&#39;</span> <span class="n">AND</span> <span class="n">constraint_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">);</span>

<span class="n">CONSTRAINT_NAME</span>
<span class="o">-----------------------------------------------------</span>
<span class="n">SYS_C0029334</span>
</pre></div>
</div>
<p>Oh, we can see that is…..much worse.  Oracle’s names are entirely unpredictable
alphanumeric codes, and this will make being able to write migrations
quite tedious, as we’d need to look up all these names.</p>
<p>The solution to having to look up names is to make your own names.   This is
an easy, though tedious thing to do manually.  For example, to create our model
in SQLAlchemy ensuring we use names for foreign key constraints would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
              <span class="p">)</span>

<span class="n">user_order</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_order&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_order_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span>
                    <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user_account.id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fk_user_order_id&#39;</span><span class="p">))</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>Simple enough, though this has some disadvantages.  The first is that it’s tedious;
we need to remember to use a name for every <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.ForeignKey" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> object,
not to mention every <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>, <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.CheckConstraint" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CheckConstraint</span></code></a>,
<a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.Index" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>, and maybe even <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a>
as well if we wish to be able to alter those too, and beyond all that, all the
names have to be globally unique.   Even with all that effort, if we have a naming scheme in mind,
it’s easy to get it wrong when doing it manually each time.</p>
<p>What’s worse is that manually naming constraints (and indexes) gets even more
tedious in that we can no longer use convenience features such as the <code class="docutils literal notranslate"><span class="pre">.unique=True</span></code>
or <code class="docutils literal notranslate"><span class="pre">.index=True</span></code> flag on <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Column" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">unique=True</span></code> flag creates a <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>, but again,
it’s not named.   If we want to name it, manually we have to forego the usage
of <code class="docutils literal notranslate"><span class="pre">unique=True</span></code> and type out the whole constraint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_account</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_account&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
                  <span class="n">UniqueConstraint</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;uq_user_account_name&#39;</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>There’s a solution to all this naming work, which is to use an <strong>automated
naming convention</strong>.  For some years, SQLAlchemy has encourgaged the use of
DDL Events in order to create naming schemes.  The <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/events.html#sqlalchemy.events.DDLEvents.after_parent_attach" title="(in SQLAlchemy v1.4)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">after_parent_attach()</span></code></a>
event in particular is the best place to intercept when <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.Constraint" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constraint</span></code></a>
and <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#sqlalchemy.schema.Index" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> objects are being associated with a parent
<a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Table" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object, and to assign a <code class="docutils literal notranslate"><span class="pre">.name</span></code> to the constraint while making
use of the name of the table and associated columns.</p>
<p>But there is also a better way to go, which is to make use of a feature
new in SQLAlchemy 0.9.2 which makes use of the events behind the scenes known as
<code class="xref py py-paramref docutils literal notranslate"><span class="pre">naming_convention</span></code>.   Here, we can
create a new <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object while passing a dictionary referring
to a naming scheme:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">convention</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">&quot;ix&quot;</span><span class="p">:</span> <span class="s2">&quot;ix_</span><span class="si">%(column_0_label)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;uq&quot;</span><span class="p">:</span> <span class="s2">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ck&quot;</span><span class="p">:</span> <span class="s2">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(constraint_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fk&quot;</span><span class="p">:</span> <span class="s2">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">_</span><span class="si">%(referred_table_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="s2">&quot;pk&quot;</span><span class="p">:</span> <span class="s2">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s2">&quot;</span>
<span class="p">}</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="n">convention</span><span class="p">)</span>
</pre></div>
</div>
<p>If we define our models using a <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.MetaData" title="(in SQLAlchemy v1.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> as above, the given
naming convention dictionary will be used to provide names for all constraints
and indexes.</p>
<section id="integration-of-naming-conventions-into-operations-autogenerate">
<span id="autogen-naming-conventions"></span><h2>Integration of Naming Conventions into Operations, Autogenerate<a class="headerlink" href="#integration-of-naming-conventions-into-operations-autogenerate" title="Permalink to this headline">¶</a></h2>
<p>As of Alembic 0.6.4, the naming convention feature is integrated into the
<a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operations</span></code></a> object, so that the convention takes effect for any
constraint that is otherwise unnamed.  The naming convention is passed to
<a class="reference internal" href="ops.html#alembic.operations.Operations" title="alembic.operations.Operations"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operations</span></code></a> using the <code class="xref py py-paramref docutils literal notranslate"><span class="pre">MigrationsContext.configure.target_metadata</span></code>
parameter in <code class="docutils literal notranslate"><span class="pre">env.py</span></code>, which is normally configured when autogenerate is
used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in your application&#39;s model:</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;ix&quot;</span><span class="p">:</span> <span class="s2">&quot;ix_</span><span class="si">%(column_0_label)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;uq&quot;</span><span class="p">:</span> <span class="s2">&quot;uq_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ck&quot;</span><span class="p">:</span> <span class="s2">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(constraint_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;fk&quot;</span><span class="p">:</span> <span class="s2">&quot;fk_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">_</span><span class="si">%(referred_table_name)s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pk&quot;</span><span class="p">:</span> <span class="s2">&quot;pk_</span><span class="si">%(table_name)s</span><span class="s2">&quot;</span>
      <span class="p">})</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

<span class="c1"># .. in your Alembic env.py:</span>

<span class="c1"># add your model&#39;s MetaData object here</span>
<span class="c1"># for &#39;autogenerate&#39; support</span>
<span class="kn">from</span> <span class="nn">myapp</span> <span class="kn">import</span> <span class="n">mymodel</span>
<span class="n">target_metadata</span> <span class="o">=</span> <span class="n">mymodel</span><span class="o">.</span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span>

<span class="c1"># ...</span>

<span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">():</span>

    <span class="c1"># ...</span>

    <span class="n">context</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span>
                <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span>
                <span class="p">)</span>
</pre></div>
</div>
<p>Above, when we render a directive like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s1">&#39;sometable&#39;</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;q_bool&#39;</span><span class="p">)))</span>
</pre></div>
</div>
<p>The Boolean type will render a CHECK constraint with the name
<code class="docutils literal notranslate"><span class="pre">&quot;ck_sometable_q_bool&quot;</span></code>, assuming the backend in use does not support
native boolean types.</p>
<p>We can also use op directives with constraints and not give them a name
at all, if the naming convention doesn’t require one.  The value of
<code class="docutils literal notranslate"><span class="pre">None</span></code> will be converted into a name that follows the appropriate naming
conventions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;some_table&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When autogenerate renders constraints in a migration script, it renders them
typically with their completed name.  If using at least Alembic 0.6.4 as well
as SQLAlchemy 0.9.4, these will be rendered with a special directive
<a class="reference internal" href="ops.html#alembic.operations.Operations.f" title="alembic.operations.Operations.f"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operations.f()</span></code></a> which denotes that the string has already been
tokenized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">upgrade</span><span class="p">():</span>
    <span class="n">op</span><span class="o">.</span><span class="n">create_unique_constraint</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="s1">&#39;uq_const_x&#39;</span><span class="p">),</span> <span class="s1">&#39;some_table&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more detail on the naming convention feature, see <a class="reference external" href="https://docs.sqlalchemy.org/en/14/core/constraints.html#constraint-naming-conventions" title="(in SQLAlchemy v1.4)"><span>Configuring Constraint Naming Conventions</span></a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYIL23W&placement=alembiczzzcomputingcom" id="_carbonads_js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-28532944-2', 'auto');
  ga('send', 'pageview');

</script>


<p>
<a href="alembic_latest.zip">Download documentation as ZIP file</a>
</p>


  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Importance of Naming Constraints</a><ul>
<li><a class="reference internal" href="#integration-of-naming-conventions-into-operations-autogenerate">Integration of Naming Conventions into Operations, Autogenerate</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h4>Previous topic</h4>
  <p class="topless"><a href="offline.html"
                        title="previous chapter">Generating SQL Scripts (a.k.a. “Offline Mode”)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="batch.html"
                        title="next chapter">Running “Batch” Migrations for SQLite and Other Databases</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="batch.html" title="Running “Batch” Migrations for SQLite and Other Databases"
             >next</a> |</li>
        <li class="right" >
          <a href="offline.html" title="Generating SQL Scripts (a.k.a. “Offline Mode”)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Alembic 1.7.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Importance of Naming Constraints</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2021, Mike Bayer.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>