# Including CHECK constraints

**包括 CHECK 约束**

[Boolean]: https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.Boolean
[Enum]: https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.Enum

As of Alembic 1.7, **named** CHECK constraints are automatically included in batch mode, as modern SQLAlchemy versions are capable of reflecting these constraints like any other constraint.

Note that when dropping or renaming a column that is mentioned in a named CHECK constraint, this CHECK constraint must be explicitly dropped first, as Alembic has no means of linking a reflected CHECK constraint to that column. Supposing column `q` of `some_table` were mentioned in a CHECK constraint named ck1. In order to drop this column, we have to drop the check constraint also:

```python
with self.op.batch_alter_table("some_table") as batch_op:
    batch_op.drop_constraint("ck1", "check")
    batch_op.drop_column('q')
```

> *Changed in version 1.7*: Named CHECK constraints participate in batch mode in the same way as any other kind of constraint. This requires that column drops or renames now include explicit directives to drop an existing named constraint which refers to this column, as it will otherwise not be automatically detected as being associated with that particular column.
>
> Unnamed CHECK constraints continue to be silently omitted from the table recreate operation.

For **unnamed** CHECK constraints, these are still not automatically included as part of the batch process. Note that this limitation **includes** the CHECK constraints generated by the **[Boolean]** or **[Enum]** datatypes, which up through SQLAlchemy 1.3 would generate CHECK constraints automatically and cannot be tracked to the reflected table, assuming they are generated in an **unnamed** way.

Unnamed constraints can be stated explicitly if they are to be included in the recreated table:

```python
with op.batch_alter_table("some_table", table_args=[
      CheckConstraint('x > 5')
  ]) as batch_op:
    batch_op.add_column(Column('foo', Integer))
    batch_op.drop_column('bar')
```

The above step needs only be taken for CHECK constraints that are explicitly stated as part of the table definition.

For CHECK constraints that are generated by datatypes such as **[Boolean]** or Enum, the type objects themselves **must be named** in order for their CHECK constraints to be included in the batch process. **[Boolean]** and **[Enum]** datatypes that do **not** have the `.name` attribute set will **not** have CHECK constraints regenerated. This name can be set by specifying the `.name` parameter or by using a named Python **[Enum]** object as the source of enumeration.
