# What does Autogenerate Detect

[EnvironmentContext.configure.compare_type]: ../en/api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_type
[Comparing Types]: ../en/autogenerate.html#compare-types
[EnvironmentContext.configure.compare_server_default]: ../en/api/runtime.html#alembic.runtime.environment.EnvironmentContext.configure.params.compare_server_default
[The Importance of Naming Constraints]: ../en/naming.html
[Enum]: https://docs.sqlalchemy.org/en/14/core/type_basics.html#sqlalchemy.types.Enum
[sqlalchemy.events.DDLEvents.column_reflect()]: https://docs.sqlalchemy.org/en/14/core/events.html#sqlalchemy.events.DDLEvents.column_reflect
[sqlalchemy.events.DDLEvents.after_parent_attach()]: https://docs.sqlalchemy.org/en/14/core/events.html#sqlalchemy.events.DDLEvents.after_parent_attach

The vast majority of user issues with Alembic centers on the topic of what kinds of changes autogenerate can and cannot detect reliably, as well as how it renders Python code for what it does detect. It is critical to note that **autogenerate is not intended to be perfect**. It is *always* necessary to manually review and correct the **candidate migrations** that autogenerate produces. The feature is getting more and more comprehensive and error-free as releases continue, but one should take note of the current limitations.

Autogenerate **will detect**:

* Table additions, removals.
* Column additions, removals.
* Change of nullable status on columns.
* Basic changes in indexes and explicitly-named unique constraints
* Basic changes in foreign key constraints

Autogenerate can **optionally detect**:

* Change of column type. This will occur if you set the **[EnvironmentContext.configure.compare_type]** parameter to `True`. The default implementation will reliably detect major changes, such as between **Numeric** and **String**, as well as accommodate for the types generated by SQLAlchemy’s “generic” types such as **Boolean**. Arguments that are shared between both types, such as length and precision values, will also be compared. If either the metadata type or database type has **additional** arguments beyond that of the other type, these are **not** compared, such as if one numeric type featured a “scale” and other type did not, this would be seen as the backing database not supporting the value, or reporting on a default that the metadata did not specify.

    The type comparison logic is fully extensible as well; see [Comparing Types] for details.

    > Changed in version 1.4: type comparison code has been reworked such that column types are compared based on their rendered DDL, which should allow the functionality enabled by **[EnvironmentContext.configure.compare_type]** to be much more accurate, correctly accounting for the behavior of SQLAlchemy “generic” types as well as major arguments specified within types.

* Change of server default. This will occur if you set the **[EnvironmentContext.configure.compare_server_default]** parameter to True, or to a custom callable function. This feature works well for simple cases but cannot always produce accurate results. The Postgresql backend will actually invoke the “detected” and “metadata” values against the database to determine equivalence. The feature is off by default so that it can be tested on the target schema first. Like type comparison, it can also be customized by passing a callable; see the function’s documentation for details.

Autogenerate can **not detect**:

* Changes of table name. These will come out as an add/drop of two different tables, and should be hand-edited into a name change instead.
* Changes of column name. Like table name changes, these are detected as a column add/drop pair, which is not at all the same as a name change.
* Anonymously named constraints. Give your constraints a name, e.g. **UniqueConstraint('col1', 'col2', name="my_name")**. See the section [The Importance of Naming Constraints] for background on how to configure automatic naming schemes for constraints.
* Special SQLAlchemy types such as **[Enum]** when generated on a backend which doesn’t support ENUM directly - this because the representation of such a type in the non-supporting database, i.e. a CHAR+ CHECK constraint, could be any kind of CHAR+CHECK. For SQLAlchemy to determine that this is actually an ENUM would only be a guess, something that’s generally a bad idea. To implement your own “guessing” function here, use the **[sqlalchemy.events.DDLEvents.column_reflect()]** event to detect when a CHAR (or whatever the target type is) is reflected, and change it to an ENUM (or whatever type is desired) if it is known that that’s the intent of the type. The **[sqlalchemy.events.DDLEvents.after_parent_attach()]** can be used within the autogenerate process to intercept and un-attach unwanted CHECK constraints.

Autogenerate can’t currently, but **will eventually detect**:

* Some free-standing constraint additions and removals may not be supported, including PRIMARY KEY, EXCLUDE, CHECK; these are not necessarily implemented within the autogenerate detection system and also may not be supported by the supporting SQLAlchemy dialect.

* Sequence additions, removals - not yet implemented.
